/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */

#include "synth2.h"

void Synth2_osc_type_init(Synth2_osc_type& _ctx) {
   Synth2_change_type_init(_ctx.inst_177e5);
   Synth2_dcblock_type_init(_ctx.inst_24fe5);
   _ctx.m = 0.0f;
   _ctx.output = 0.0f;
   _ctx.phase = 0.0f;
   _ctx.rate = 0.0f;
   _ctx.state_pulse = 0.0f;
   _ctx.state_saw = 0.0f;
   _ctx.state_triang = 0.0f;
}

void Synth2_mono_noteOn_type_init(Synth2_mono_noteOn_type& _ctx) {
   _ctx.count = 0;
   int32_t i_0 = 0;
   while ((i_0 < 4)) {
      _ctx.notes[i_0] = 0;
      i_0 = (i_0 + 1);
   }
   _ctx.pre = 0;
}

void Synth2_process_type_init(Synth2_process_type& _ctx) {
   _ctx.amp_s = 0.0f;
   _ctx.cut = 0.0f;
   Synth2_lfo_type_init(_ctx.inst_15fb7);
   Synth2_osc_type_init(_ctx.inst_2e5b7);
   Synth2_smooth_type_init(_ctx.inst_3dfb7);
   Synth2_svf_type_init(_ctx.inst_4a7b7);
   _ctx.lfo_amt = 0.0f;
   _ctx.lfo_rate = 0.0f;
   Synth2_mono_noteOn_type_init(_ctx.monoin_02b7);
   _ctx.pitch = 0.0f;
   _ctx.pw = 0.0f;
   _ctx.res = 0.0f;
   _ctx.volume = 0.0f;
   _ctx.wave = 0.0f;
}

float Synth2_osc(Synth2_osc_type& _ctx, float pitch, float pw, float wave) {
   float fixed_pitch = 0.0f;
   if ((wave < (2.0f / 3.0f))) {
      fixed_pitch = pitch;
   }
   else {
      fixed_pitch = (pitch + 12.0f);
   }
   if (Synth2_change(_ctx.inst_177e5, fixed_pitch)) {
      _ctx.rate = Synth2_pitchToRate(fixed_pitch);
      float p = (1.0f / _ctx.rate);
      float maxHarmonics = floor((p / 2.0f));
      _ctx.m = ((2.0f * maxHarmonics) + 1.0f);
   }
   float shift05 = (0.5f + (pw * 0.49f));
   float shift = (_ctx.phase + shift05);
   if ((shift > 1.0f)) {
      shift = (shift - 1.0f);
   }
   float tmp1 = Synth2_pulse_train(_ctx.m, _ctx.phase);
   float tmp2 = Synth2_pulse_train(_ctx.m, shift);
   _ctx.phase = (_ctx.phase + _ctx.rate);
   if ((_ctx.phase > 1.0f)) {
      _ctx.phase = (_ctx.phase - 1.0f);
   }
   _ctx.state_pulse = float_clip((((_ctx.state_pulse * 0.9995f) + tmp1) - tmp2), (-1.0f), 1.0f);
   _ctx.state_saw = float_clip(((_ctx.state_saw * 0.9995f) + ((((tmp1 + tmp2) - (2.0f * _ctx.rate)) / shift05) / 2.0f)), (-1.0f), 1.0f);
   _ctx.state_triang = float_clip(((_ctx.state_triang * 0.9995f) + ((2.0f * _ctx.state_pulse) * _ctx.rate)), (-1.0f), 1.0f);
   if ((wave < (1.0f / 3.0f))) {
      _ctx.output = _ctx.state_pulse;
   }
   else {
      if ((wave < (2.0f / 3.0f))) {
         _ctx.output = (2.0f * _ctx.state_saw);
      }
      else {
         _ctx.output = ((2.0f * _ctx.state_triang) * (1.0f + pw));
      }
   }
   _ctx.output = Synth2_dcblock(_ctx.inst_24fe5, _ctx.output);
   return float_clip((_ctx.output / 4.0f), (-1.0f), 1.0f);
}

float Synth2_svf_step(Synth2_svf_step_type& _ctx, float input, float g, float q, int32_t sel) {
   float low = (_ctx.dlow + (g * _ctx.dband));
   float high = ((input - low) - (q * _ctx.dband));
   float band = ((g * high) + _ctx.dband);
   float notch = (high + low);
   _ctx.dband = float_clip(band, (-1.0f), 1.0f);
   _ctx.dlow = float_clip(low, (-1.0f), 1.0f);
   float output = 0.0f;
   if (sel == 0) {
      output = low;
   }
   else {
      if (sel == 1) {
         output = high;
      }
      else {
         if (sel == 2) {
            output = band;
         }
         else {
            output = notch;
         }
      }
   }
   return output;
}

float Synth2_lfo(Synth2_lfo_type& _ctx, float f, bool gate) {
   float rate = (((f * 100.0f) * Synth2_minFixed()) + Synth2_minFixed());
   if (Synth2_edge(_ctx.inst_1445f, gate)) {
      _ctx.phase = 0.0f;
   }
   if (Synth2_each(_ctx.inst_2cb5f, 4)) {
      _ctx.phase = (_ctx.phase + rate);
   }
   if ((_ctx.phase > 1.0f)) {
      _ctx.phase = (_ctx.phase - 1.0f);
   }
   return (sin(((_ctx.phase * 2.0f) * 3.14159265359f)) + 0.5f);
}

int32_t Synth2_mono_noteOn(Synth2_mono_noteOn_type& _ctx, int32_t n) {
   if ((_ctx.count < 4)) {
      int_set(_ctx.notes, _ctx.count, n);
      _ctx.pre = n;
      if ((_ctx.count < 4)) {
         _ctx.count = (_ctx.count + 1);
      }
   }
   return _ctx.pre;
}

int32_t Synth2_mono_noteOff(Synth2_mono_noteOn_type& _ctx, int32_t n) {
   bool found = false;
   int32_t i = 0;
   int32_t pos = 0;
   if (_ctx.count == 0) {
      return _ctx.pre;
   }
   while (((i < 4) && (found == false))) {
      if (int_get(_ctx.notes, i) == n) {
         pos = i;
         found = true;
      }
      i = (i + 1);
   }
   if (found) {
      int32_t k = (pos + 1);
      while ((k < 4)) {
         int_set(_ctx.notes, (k - 1), int_get(_ctx.notes, k));
         k = (k + 1);
      }
      if ((found && (_ctx.count > 0))) {
         _ctx.count = (_ctx.count - 1);
         _ctx.pre = int_get(_ctx.notes, (_ctx.count - 1));
      }
   }
   return _ctx.pre;
}

void Synth2_controlChange(Synth2_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
   float value_0_1 = (int_to_float(value) / 127.0f);
   float value_m1_1 = ((value_0_1 * 2.0f) - 1.0f);
   if (control == 30) {
      _ctx.volume = value_0_1;
   }
   if (control == 31) {
      _ctx.wave = value_0_1;
   }
   if (control == 32) {
      _ctx.pw = value_0_1;
   }
   if (control == 33) {
      _ctx.lfo_rate = value_0_1;
   }
   if (control == 34) {
      _ctx.lfo_amt = value_m1_1;
   }
   if (control == 35) {
      _ctx.cut = value_0_1;
   }
   if (control == 36) {
      _ctx.res = value_0_1;
   }
}

void Synth2_default(Synth2_process_type& _ctx) {
   _ctx.volume = 1.0f;
   _ctx.pw = 0.0f;
   _ctx.pitch = 42.0f;
   _ctx.cut = 1.0f;
   _ctx.res = 0.0f;
   _ctx.amp_s = 1.0f;
   _ctx.lfo_amt = 0.5f;
   _ctx.lfo_rate = 0.0f;
}

