/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */
#ifndef VOLUME_H
#define VOLUME_H

#include "vultin.h"
#include "volume.tables.h"

typedef struct Volume_smooth_type {
   float x;
} Volume_smooth_type;

typedef struct Volume_process_type {
   Volume_smooth_type inst_1d7d3;
   float volume;
} Volume_process_type;

static_inline void Volume_smooth_type_init(Volume_smooth_type& _ctx) {
   _ctx.x = 0.0f;
}

static_inline void Volume_process_type_init(Volume_process_type& _ctx) {
   Volume_smooth_type_init(_ctx.inst_1d7d3);
   _ctx.volume = 0.0f;
}

static_inline float Volume_smooth(Volume_smooth_type& _ctx, float input) {
   _ctx.x = (_ctx.x + ((input - _ctx.x) * 0.005f));
   return _ctx.x;
}

static_inline float Volume_process(Volume_process_type& _ctx, float input) {
   return (input * Volume_smooth(_ctx.inst_1d7d3, _ctx.volume));
}

static_inline void Volume_noteOn(Volume_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
}

static_inline void Volume_noteOff(Volume_process_type& _ctx, int32_t note, int32_t channel) {
}

static_inline void Volume_controlChange(Volume_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
   if (control == 30) {
      _ctx.volume = (int_to_float(value) / 127.0f);
   }
}

static_inline void Volume_default(Volume_process_type& _ctx) {
   _ctx.volume = 0.0f;
}


#endif // VOLUME_H
